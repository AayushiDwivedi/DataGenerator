options
{
    LOOKAHEAD=3;
}

PARSER_BEGIN(CSPParser)

package org.finra.datagenerator.csp.parse;

import java.util.List;
import java.util.LinkedList;
import org.finra.datagenerator.csp.constraints.*;
import org.finra.datagenerator.csp.*;

public class CSPParser {
    public ConstraintSatisfactionProblem parse() {
        try {
            return CSP();
        } catch (Throwable e) {
            System.out.println(e.toString());
            return null;
        }
    }
}

PARSER_END(CSPParser)

SKIP:  { " " | "\t" | "\n" | "\r" }
TOKEN: { "@" | "{" | "}" | "[" | "]" | "," | "@END"}
TOKEN: { "&&" | "||" | "!" | "->" | "T"}
TOKEN: { "==" | "~=" }
TOKEN: { < LITERAL: (["0"-"9"]|["A"-"Z"]|["a"-"z"])+ > }

ConstraintSatisfactionProblem CSP(): {
    ConstraintSatisfactionProblem csp;
    Constraint constraint;
    Token variable;
    List<String> domain;
}{
    "@END"
    {
        csp = new ConstraintSatisfactionProblem();
        return csp;
    }

    | "@" variable = <LITERAL> "{" domain = DOMAIN() "}" "[" constraint = CONSTRAINT() "]" csp = CSP()
    {
        csp.addLevel(variable.image, domain, constraint);
        return csp;
    }
}

List<String> DOMAIN(): {
    List<String> domain;
    Token element;
}{
    element = <LITERAL> "," domain = DOMAIN()
    {
        domain.add(element.image);
        return domain;
    }

    | element = <LITERAL>
    {
        domain = new LinkedList<String>();
        domain.add(element.image);
        return domain;
    }
}

Constraint CONSTRAINT():{
    Constraint one, two;
}{
    "&&" one = CONSTRAINT() two = CONSTRAINT()
    {
        return new AndConstraint(one,two);
    }

    | "||" one = CONSTRAINT() two = CONSTRAINT()
    {
        return new OrConstraint(one,two);
    }

    | "->" one = CONSTRAINT() two = CONSTRAINT()
    {
        return new ImplyConstraint(one,two);
    }

    | "!" one = CONSTRAINT()
    {
        return new NotConstraint(one);
    }

    | "T"
    {
        return new Tautology();
    }

    | one = ATOMIC()
    {
        return one;
    }
}

Constraint ATOMIC():{
    List<String> domain;
    Token one, two;
}{
    "==" one = <LITERAL> two = <LITERAL> {
        return new EqualConstraint(one.image, two.image);
    }

    | "~=" one = <LITERAL> two = <LITERAL> {
        return new DisequalConstraint(one.image, two.image);
    }

    | one = <LITERAL> "{" domain = DOMAIN() "}" {
        return new AmongstConstraint(one.image, domain);
    }
}